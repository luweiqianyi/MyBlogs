# 安卓消息机制

**以下源码皆基于安卓SDK版本：android-28**

## Message篇

## Handler篇

对于Handler，我们主要讲解两个方面：

* Handler是如何处理消息的
* Handler发送消息的常用方式以及内部原理

### Handler是如何处理消息的

首先，针对消息的处理，Handler内部提供了三种处理方式，具体可以参照Handler内部`dispatchMessage`的源码，如下：

```java
1	public void dispatchMessage(Message msg) {
2        if (msg.callback != null) {
3            handleCallback(msg);
4        } else {
5            if (mCallback != null) {
6                if (mCallback.handleMessage(msg)) {
7                    return;
8                }
9            }
10            handleMessage(msg);
11       }
12   }
```

首先，我们可以看到针对消息msg来说，如果它自己被指定默认的消息处理函数，则调用该函数进行处理,具体体现在上述代码第三行，那么该函数具体做了什么事，那么我们看一下安卓Handler类对于该方法的实现,如下：

```java
private static void handleCallback(Message message) {
	message.callback.run();
}
```

先不着急，我们在看一下Message类中的callback是个什么，继续查找源码，如下：

```java
public final class Message implements Parcelable {
    // 以上省略其他的成员变量和成员函数
    
    /*package*/ Runnable callback;
    
    // 以下省略其他的成员变量和成员函数
}
```

众所周知，Runnable是一个内部只定义了一个run方法的接口。那么结合`dispatchMessage`、`handleCallback`、Message类来看，我们可以知道**Handler处理消息的整个逻辑：**

1. **对于Handler对象，如果其处理消息时，消息自己被设置了某一消息处理函数，那么就会优先调用该函数对消息进行处理;**
2. **如果没有为要处理的消息对象指定消息处理函数，且Handler对象自己被指定了消息处理函数，即`mCallback`的值不为空，则优先调用`mCallback`的消息处理函数，即`mCallback.handleMessage`函数;** 
3. **若Handler对象自己没有被指定消息处理函数，则调用Handler对象自己内部的成员函数来处理消息，即`handleMessage`函数**



针对以上第2点、第3点结论的推出，我们可以结合`dispatchMessage`函数的处理逻辑和以下代码块分析推理得出

`mCallback`是Handler类内部的一个成员变量，其相关的声明如下：

```java
final Callback mCallback;

// Callback 是Handler类内部定义的接口
public interface Callback {
        /**
         * @param msg A {@link android.os.Message Message} object
         * @return True if no further handling is desired
         */
        public boolean handleMessage(Message msg);
    }

	// 这个是Handler内部自己的成员函数，我们可以很清楚的知道，
    // 如果调用dispatchMessage的对象是Handler声明出来的，那么handleMessage实际上什么也没有做
    // 如果调用dispatchMessage的对象是Handler的子类声明出来的，并且这个子类重新实现了handleMessage
    // 函数，那么就会使用子类实现的处理逻辑对消息进行处理，当然这个前提是前面提到过的第1点、第2点都不会执行	  // 的前提下
	/**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(Message msg) {
    }
```

那么问题就来了，`mCallback`是什么时候指定的？熟悉Spring的同学肯定都知道，里面有一个“依赖注入”的概念，那么针对`mCallback`成员变量的设置，我们猜想要么可以通过“构造器注入”或者“set注入”的方式来为`mCallback`变量进行赋值，对于我们的Handler来说，采取的是“构造器注入”的方式，具体可以查看Handler的构造函数。下面简单的贴一下与`mCallback`相关的Handler构造函数的实现，其他的Handler的构造函数的实现不予展示，感兴趣的同学可以自行查阅Handler的源码。

```java
1  public Handler(Callback callback, boolean async) {
2          if (FIND_POTENTIAL_LEAKS) {
3              final Class<? extends Handler> klass = getClass();
4              if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
5                      (klass.getModifiers() & Modifier.STATIC) == 0) {
6                  Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
7                      klass.getCanonicalName());
8              }
9         }
10
11         mLooper = Looper.myLooper();
12         if (mLooper == null) {
13              throw new RuntimeException(
14                  "Can't create handler inside thread " + Thread.currentThread()
15                          + " that has not called Looper.prepare()");
16         }
17         mQueue = mLooper.mQueue;
18         mCallback = callback;
19         mAsynchronous = async;
20 }
21
22   public Handler(Looper looper, Callback callback, boolean async) {
23        mLooper = looper;
24        mQueue = looper.mQueue;
25        mCallback = callback;
26        mAsynchronous = async;
27    }

```

**如上源码所示，第18行和第25行为Handler的`mCallback`指定了值。**

### Handler发送消息的常用方式以及内部原理

Handler对于消息的发送方式有以下几种函数可供调用:

```java
public final boolean post(Runnable r);
public final boolean postAtTime(Runnable r, long uptimeMillis);
public final boolean postAtTime(Runnable r, Object token, long uptimeMillis);
public final boolean postDelayed(Runnable r, long delayMillis);
public final boolean postDelayed(Runnable r, Object token, long delayMillis);
public final boolean postAtFrontOfQueue(Runnable r);
public final boolean sendMessage(Message msg);
public final boolean sendEmptyMessage(int what);
public final boolean sendEmptyMessageDelayed(int what, long delayMillis);
public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis);
public final boolean sendMessageDelayed(Message msg, long delayMillis);
public boolean sendMessageAtTime(Message msg, long uptimeMillis);
public final boolean sendMessageAtFrontOfQueue(Message msg);
public final boolean executeOrSendMessage(Message msg);
```

查看以上函数的源码，其最终都是调用到Handler类中的下面这个函数，注意是私有方法：

```java
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis){
    msg.target = this;
    if (mAsynchronous) {
       msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
```

**其中，这个queue对象是Handler类中的`mQueue`成员变量。**那么问题来了，这个`mQueue`变量是哪里设置的，是“构造器注入”还是“set注入”?通过查看Handler类的源码，我们发现只有两个地方对这个`mQueue`变量进行了赋值。代码如下：

```java
public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;  // 在这里被赋值
        mCallback = callback;
        mAsynchronous = async;
}

public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper(); // 取到mLooper对象
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;  // 在这里被赋值
        mCallback = callback;
        mAsynchronous = async;
}
```

根据以上源码可知，我们知道在Handler对象被构造的时候就可以为成员变量`mQueue`指定相应的值。第一段代码指定是外来传进来的looper对象中的`mQueue`,第二段代码取的则是`Looper.myLooper().mQueue`。这里，我们重点关于第二段代码。这时候，我们的第一个疑问就是：**`Looper.myLooper()`是个什么玩意儿？它有什么用？是干什么的？** 强行三连，最为致命！我们先把这个疑惑放在一边，只需要知道，这个`mQueue`是从某个Looper对象中来的，不管它是外部的Looper对象设进来还是`Looper.myLooper()`设进来的。我们先看看那个`return queue.enqueueMessage(msg, uptimeMillis);`这行代码是做什么的。那么就需要到`MessageQueue`这个类中去查看了，那么接下来进入我们的`MessageQueue`篇。

## `MessageQueue`篇

在Handler篇，章节"Handler发送消息的常用方式以及内部原理"的末尾部分，我们提到了`enqueueMessage`这个函数，那么我们就详细看看它的源码实现。

```java
1  boolean enqueueMessage(Message msg, long when) {
2          if (msg.target == null) {
3              throw new IllegalArgumentException("Message must have a target.");
4          }
5          if (msg.isInUse()) {
6              throw new IllegalStateException(msg + " This message is already in use.");
7          }
8
9          synchronized (this) {
10              if (mQuitting) {
11                  IllegalStateException e = new IllegalStateException(
12                          msg.target + " sending message to a Handler on a dead thread");
13                  Log.w(TAG, e.getMessage(), e);
14                  msg.recycle();
15                  return false;
16              }
17
18              msg.markInUse();
19              msg.when = when;
20              Message p = mMessages;
21              boolean needWake;
22              if (p == null || when == 0 || when < p.when) {
23                  // New head, wake up the event queue if blocked.
24                  msg.next = p;
25                  mMessages = msg;
26                  needWake = mBlocked;
27              } else {
28                  // Inserted within the middle of the queue.  Usually we don't have to wake
29                  // up the event queue unless there is a barrier at the head of the queue
30                  // and the message is the earliest asynchronous message in the queue.
31                  needWake = mBlocked && p.target == null && msg.isAsynchronous();
32                  Message prev;
33                  for (;;) {
34                      prev = p;
35                      p = p.next;
36                      if (p == null || when < p.when) {
37                          break;
38                      }
39                      if (needWake && p.isAsynchronous()) {
40                          needWake = false;
41                      }
42                  }
43                  msg.next = p; // invariant: p == prev.next
44                  prev.next = msg;
45              }
46  
47              // We can assume mPtr != 0 because mQuitting is false.
48              if (needWake) {
49                  nativeWake(mPtr);
50              }
51          }
52          return true;
53}
```

逐块来看代码功能：

* line2到line7, 做一些检查：检查消息msg是否有对应的Handler对象和msg当前是否在被使用。
* line9告诉我们：以下的过程是只允许一个线程进行处理，是需要做线程安全处理的。
* line10到line16：告诉我们如果`mQuitting`为真,那么对消息msg进行回收处理。
* line18：将消息标记为正在使用
* line19:  设置消息的处理时间（**主要用来排消息在消息队列中的位置**），有以下几种方式：
  * 系统启动后，当前调用postXXX或者sendXXX这类方法的时间作为时间标记，这个时间标记仅用来安排消息在消息队列中的位置，而不是消息的执行时间
  * 在上面的时间标记的基础上，再往后延一定的时间
  * 人为指定一个时间标记，很灵活
* line20: `mMessages`其实是由各个Message链接起来的链表结构，关于链表可自行查阅《数据结构与算法》中的链表章节。`mMessages`可能为空，表示一个消息也没有；也可能不为空，表示至少已经有一个Message在这个链上。
* line22到line27：链表为空或者新进来的消息的when值比链表头部节点的when值小，则将新进来的消息加入链表的头部
* line32到line44:  链表不为空且新加入的消息的when值比链表头部节点的when值大，则与链表中的其他节点的when值进行比较，一直找到比链表中某个节点的when值小为止，然后将新的消息插入找到的那个节点的前面。(其现实意义就是：链表中的消息是按照进入队列中那个时间点的值进行排列的，早进入队列的消息的when值小，所以需要排在靠近链表头部的位置，晚进入队列的消息的when值大，所以需要排在靠近链表尾部的位置，这样就以链表的形式完成了一个消息的队列结构)。具体的图像化的分析过程可以参照 [我的博客](https://github.com/luweiqianyi/MyBlogs/blob/master/graphviz%E7%BB%98%E5%88%B6%E9%93%BE%E8%A1%A8/graphviz%E7%BB%98%E5%88%B6%E9%93%BE%E8%A1%A8.md)。

## Looper篇

